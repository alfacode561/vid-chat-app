<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Chat Example</title>
    <!-- Previous CSS styles remain unchanged -->
</head>
<body class="bg-gray-100 p-6">
    <!-- Previous HTML content remains unchanged -->
    <div id="status" class="text-gray-600 mt-4"></div>
</div>

<script>
let localStream;
let remoteStream;
let peerConnection;
let friendID;

const configuration = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' }
    ]
};

const startButton = document.getElementById('startButton');
const callButton = document.getElementById('callButton');
const hangupButton = document.getElementById('hangupButton');
const localVideo = document.getElementById('localVideo');
const remoteVideo = document.getElementById('remoteVideo');
const statusDiv = document.getElementById('status');
const friendIDInput = document.getElementById('friendID');
const friendIDDisplay = document.getElementById('friendIDDisplay');

// Generate a random ID for this peer
friendIDDisplay.textContent = Math.floor(Math.random() * 1000000);

startButton.addEventListener('click', startVideo);
callButton.addEventListener('click', startCall);
hangupButton.addEventListener('click', hangup);

async function startVideo() {
    try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localVideo.srcObject = localStream;
        startButton.disabled = true;
        callButton.disabled = false;
    } catch (err) {
        console.error('Error accessing media devices:', err);
        statusDiv.textContent = 'Error accessing camera and microphone';
    }
}

async function startCall() {
    friendID = friendIDInput.value;
    if (!friendID) {
        statusDiv.textContent = 'Please enter friend\'s ID';
        return;
    }

    peerConnection = new RTCPeerConnection(configuration);
    
    // Add local stream tracks to peer connection
    localStream.getTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
    });

    // Handle incoming tracks
    peerConnection.ontrack = event => {
        remoteVideo.srcObject = event.streams[0];
    };

    // Handle ICE candidates
    peerConnection.onicecandidate = event => {
        if (event.candidate) {
            // In a real app, send this to the remote peer via your signaling server
            console.log('New ICE candidate:', event.candidate);
        }
    };

    try {
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        
        // In a real app, send this offer to the remote peer via your signaling server
        console.log('Created offer:', offer);
        
        callButton.disabled = true;
        hangupButton.disabled = false;
        statusDiv.textContent = 'Call initiated. Waiting for answer...';
    } catch (err) {
        console.error('Error creating offer:', err);
        statusDiv.textContent = 'Error creating call offer';
    }
}

function hangup() {
    if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
    }
    
    if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localVideo.srcObject = null;
    }
    
    if (remoteStream) {
        remoteStream.getTracks().forEach(track => track.stop());
        remoteVideo.srcObject = null;
    }

    startButton.disabled = false;
    callButton.disabled = true;
    hangupButton.disabled = true;
    statusDiv.textContent = 'Call ended';
}
</script>
</body>
</html>
